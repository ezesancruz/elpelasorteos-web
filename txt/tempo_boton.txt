Analisis y estrategia: Temporizador en botones del Hero

Estado actual
- Datos: Los botones del hero se configuran en `data/site-content.json` bajo `pages[].hero.buttons[]` con propiedades `label` (texto/etiqueta) y `href` (URL).
- Render: `scripts/app.js:759-771` crea los botones como `<a>` dentro de `.button-row` y aplica clases: primer botón `button--primary`, segundo `button--ghost`. Tracking con `cta_participar_click` si el label incluye "particip".
- Editor: `scripts/editor.js:296-348` muestra el panel de edición del Hero y, por cada botón, ofrece dos campos: `Etiqueta` y `URL` usando `createInput` (`scripts/editor.js:873-885`). No hay inputs numéricos por defecto, pero existe `createToggleSwitch` (útil para un checkbox) y se puede añadir un `createNumberInput` sencillo.

Objetivo solicitado
- Agregar un tercer parámetro en la edición de cada botón del Hero:
  1) "Temporizador botón" (casilla tildable)
  2) Al tildar, habilitar dos inputs numéricos: "Horas" y "Minutos".
  3) Al guardar, que el tiempo comience a correr y se muestre junto al texto del botón (cuenta regresiva).
  4) Al finalizar el tiempo, deshabilitar el botón (eliminar enlace de redirección y dejarlo inoperativo).

Factibilidad
- Técnica y UI: Factible con cambios acotados en `scripts/editor.js`, `scripts/app.js` y `styles/main.css`. No requiere backend adicional; el editor ya guarda en `data/site-content.json`.
- Persistencia del "fin de tiempo": La deshabilitación puede ser solo en tiempo de ejecución (frontend). Si se desea persistir el estado (por ejemplo, dejar `href` vacío en el JSON automáticamente una vez vencido), haría falta un mecanismo de guardado automático desde cliente (no existe hoy) o una tarea del servidor; por ahora se plantea como comportamiento de runtime.

Diseño de datos propuesto (por botón)
- Nuevos campos (en `hero.buttons[]`):
  - `timerEnabled: boolean` (default: false)
  - `timerEnd: string | number` (timestamp ISO o epoch ms) — fin absoluto de la cuenta regresiva. Se calcula al guardar a partir de horas/minutos ingresados.
  - (Opcional UI) `timerPresetHours: number`, `timerPresetMinutes: number` para rellenar los inputs cuando se reabre el editor. Alternativamente, se prellenan a partir del tiempo restante calculado desde `timerEnd`.

Cambios en el Editor (scripts/editor.js)
- En `renderHeroEditor()` (líneas ~319-333):
  - Debajo de `Etiqueta` y `URL`, añadir:
    - `createToggleSwitch('Temporizador botón', button.timerEnabled || false, onChange)` que actualice `hero.buttons[index].timerEnabled` y muestre/oculte los inputs de tiempo.
    - Dos inputs numéricos: `Horas` y `Minutos` (p. ej. nuevo helper `createNumberInput(label, value, onChange)` con `type='number'`, `min='0'`, `step='1'`). Guardar provisionalmente en `timerPresetHours` y `timerPresetMinutes`.
- En el flujo de guardado: al presionar "Guardar" (ya existente en el editor), antes de serializar el sitio:
  - Para cada botón con `timerEnabled === true`, calcular `timerEnd = Date.now() + (hours*3600000 + minutes*60000)` y persistirlo en el JSON. Si el temporizador se desactiva, limpiar `timerEnd`.
- Validaciones UI: aceptar solo enteros >= 0; si ambos son 0, mostrar aviso o no calcular `timerEnd`.

Cambios en el render (scripts/app.js)
- En `renderHero()` donde se crean los `<a>`:
  - Si `btn.timerEnabled` y `btn.timerEnd` es futuro:
    - Crear un `<span class="button-timer">` y anexarlo al botón para mostrar la cuenta (formato `HH:MM:SS` si hay horas, si no `MM:SS`).
    - Iniciar un `setInterval` (1s) que recalcule el tiempo restante: `remaining = Math.max(0, timerEnd - Date.now())`.
    - Al llegar a 0:
      - `clearInterval`.
      - Deshabilitar el botón: `anchor.removeAttribute('href')`, `anchor.setAttribute('aria-disabled','true')`, `anchor.classList.add('button--disabled')`, `anchor.tabIndex = -1`.
      - (Opcional) Cambiar el texto del timer a "Finalizado".
  - Si `btn.timerEnabled` pero `timerEnd` no válido o ya vencido, renderizar el botón ya deshabilitado con la misma lógica.
- Consideraciones de ciclo de vida: en este proyecto el DOM del Hero se recrea en cada `render()`, por lo que los intervalos previos se perderán con el nodo (GC). No se requiere almacén global de timers.

Estilos (styles/main.css)
- Añadir:
  - `.button--disabled { pointer-events: none; opacity: 0.6; filter: grayscale(0.2); }`
  - `.button .button-timer { margin-left: 0.5rem; font-weight: 600; font-variant-numeric: tabular-nums; }`
  - Ajustar contraste según la paleta existente.

Accesibilidad
- Añadir `aria-disabled="true"` al deshabilitar.
- Mantener el label original; el timer puede ir en `<span aria-hidden="true">` para no duplicar lectura en lectores de pantalla.
- Evitar cambios de layout bruscos; el span del timer ocupa poco espacio.

Limitaciones y notas
- Persistencia del estado al expirar: por defecto, solo se deshabilita en el cliente. El JSON no se actualiza automáticamente sin intervención del editor. Si se desea persistir, se podría:
  - Implementar un auto-guardado desde el cliente al expirar (requiere endpoint permitido y decisión UX), o
  - Ejecutar una tarea/cron del lado servidor que revise `timerEnd` y edite el JSON.
- Sincronización de reloj: depende del reloj del dispositivo del visitante. Para eventos críticos, considerar usar hora del servidor.
- Zonas horarias: usar `timerEnd` absoluto (UTC) evita ambigüedades.

Plan de implementación (pasos concretos)
1) Datos: extender `hero.buttons[]` con `timerEnabled` y `timerEnd` (y opcionalmente presets).
2) Editor: añadir toggle + inputs numéricos por botón; calcular `timerEnd` al guardar.
3) Render: mostrar el timer junto a la etiqueta y actualizar cada segundo; deshabilitar al expirar.
4) Estilos: agregar `.button--disabled` y `.button-timer`.
5) Pruebas: 
   - Botón con 0h 1m → cuenta correcta y bloqueo al minuto.
   - Reapertura del editor muestra el tiempo restante (o presets).
   - Botón ya vencido se muestra deshabilitado al cargar.
   - Seguimiento de clics no se dispara al estar deshabilitado.

Impacto en código
- Archivos a tocar: `scripts/editor.js`, `scripts/app.js`, `styles/main.css` y el contenido del JSON al guardar.
- Alcance enfocado: no se afectan otras secciones.

Conclusión
La funcionalidad es viable con cambios acotados en editor, render y estilos. El uso de un `timerEnd` absoluto simplifica el cálculo del tiempo restante y evita dependencias adicionales. La deshabilitación será efectiva en el cliente; si se requiere persistir el estado post-expiración en el JSON, se debería evaluar un mecanismo de guardado automático o una tarea del servidor.

