  Opción A — Usar la DB del repo (rápida)                                       
                                                                                
  - Deja solo el volumen del directorio y elimina la línea 18.                  
  - Resultado: el contenedor verá el pagos.db que está dentro de microservices/ 
    integracion_mercadopago_app en el host.                                     
  - Pasos:                                                                      
      - Edita docker-compose.yml y BORRA la línea 18.                           
      - Redeploy: docker compose up -d --build                                  
      - Verifica en contenedor:                                                 
          - docker compose exec web sh -lc 'ls -l /app/microservices/           
            integracion_mercadopago_app/pagos.db'                               
          - docker compose exec web sh -lc 'python microservices/               
            integracion_mercadopago_app/scripts/query_payment.py 123456'

    bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose up -d --build
[+] Building 35.2s (17/17) FINISHED
 => [internal] load local bake definitions                                 0.0s 
 => => reading from stdin 489B                                             0.0s 
 => [internal] load build definition from Dockerfile                       0.0s 
 => [internal] load local bake definitions                                 0.0s 
 => => reading from stdin 489B                                             0.0s 
 => [internal] load build definition from Dockerfile                       0.0s 
 => => transferring dockerfile: 721B                                       0.0s 
 => [internal] load build definition from Dockerfile                       0.0s 
 => => transferring dockerfile: 721B                                       0.0s 
 => => transferring dockerfile: 721B                                       0.0s 
 => resolve image config for docker-image://docker.io/docker/dockerfile:1  0.2s 
 => CACHED docker-image://docker.io/docker/dockerfile:1@sha256:b6afd42430  0.0s 
 => [internal] load metadata for docker.io/library/node:20-alpine          0.1s 
 => [internal] load .dockerignore                                          0.0s 
 => => transferring context: 2B                                            0.0s 
 => [1/8] FROM docker.io/library/node:20-alpine@sha256:6178e78b972f79c335  0.0s 
 => [internal] load build context                                          3.1s 
 => => transferring context: 102.10MB                                      3.0s 
 => CACHED [2/8] WORKDIR /app                                              0.0s 
 => CACHED [3/8] RUN addgroup -S appgroup && adduser -S appuser -G appgro  0.0s 
 => CACHED [4/8] COPY package*.json ./                                     0.0s 
 => CACHED [5/8] RUN npm ci --only=production                              0.0s 
 => CACHED [6/8] RUN apk add --no-cache python3  && ln -sf /usr/bin/pytho  0.0s 
 => [7/8] COPY . .                                                         1.8s 
 => [8/8] RUN chown -R appuser:appgroup /app                              24.3s 
 => exporting to image                                                     5.1s 
 => => exporting layers                                                    5.0s 
 => => writing image sha256:4f1df94cebb0548f005cecdf3c02a458e435f17a9904a  0.0s 
 => => naming to docker.io/library/web-web                                 0.0s 
 => resolving provenance for metadata file                                 0.1s 
[+] Running 3/3
 ✔ web-web              Built                                              0.0s 
 ✔ Container web-web-1  Started                                            0.4s 
 ✔ Container caddy      Started                                            0.3s 
bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose exec web sh -lc 'ls -l /app/microservices/
            integracion_mercadopago_app/pagos.db'
total 4
drwxr-xr-x    5 node     node          4096 Oct 27 22:04 integracion_mercadopago_app
sh: integracion_mercadopago_app/pagos.db: not found
bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose exec web sh -lc 'python microservices/
            integracion_mercadopago_app/scripts/query_payment.py 130455149235'
/usr/bin/python: can't find '__main__' module in '/app/microservices/'
sh: integracion_mercadopago_app/scripts/query_payment.py: not found
bitnami@ip-172-26-1-205:~/sorteo-web/web$ 



bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose exec web sh -lc 'ls -l /app/microservices/integracion_mercadopago_app/pagos.db'
-rw-r--r--    1 node     node        385024 Oct 27 04:41 /app/microservices/integracion_mercadopago_app/pagos.db

bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose exec web sh -lc 'ls -l /app/microservices/integracion_mercadopago_app/pagos.db'
-rw-r--r--    1 node     node        385024 Oct 27 04:41 /app/microservices/integracion_mercadopago_app/pagos.db
bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose exec web sh -lc 'python /app/microservicio/integracion_mercadopago_app/scripts/query_payment.py 1304551
49235'
python: can't open file '/app/microservicio/integracion_mercadopago_app/scripts/query_payment.py': [Errno 2] No such file or directory
bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose logs web | grep "/api/payments/verificar"
web-1  | GET /api/payments/verificar Error: python exit 1
bitnami@ip-172-26-1-205:~/sorteo-web/web$


bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose exec web sh -lc 'ls -l /app/microservices/integracion_mercadopago_app/pagos.db'
-rw-r--r--    1 node     node        385024 Oct 27 04:41 /app/microservices/integracion_mercadopago_app/pagos.db
bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose exec web sh -lc 'python /app/microservices/integracion_mercadopago_app/scripts/query_payment.py 130455149235 || true'
{"ok": false, "error": "Error DB: attempt to write a readonly database"}
bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose exec web sh -lc "python - <<'PY'\nimport
        sqlite3\np='/app/microservices/integracion_mercadopago_app/              
        pagos.db'\nconn=sqlite3.connect(f'file:{p}?mode=ro',                     
        uri=True)\ncur=conn.cursor()\ncur.execute("SELECT name FROM              
        sqlite_master WHERE type='table'")\nprint([r[0] for r in                 
        cur.fetchall()])\nPY"
  File "<stdin>", line 1
    sqlite3\np='/app/microservices/integracion_mercadopago_app/
IndentationError: unexpected indent
-bash: sqlite_master: command not found


bitnami@ip-172-26-1-205:~/sorteo-web/web$ 

bitnami@ip-172-26-1-205:~/sorteo-web/web$ cd ~/sorteo-web/web
git fetch origin main
git reset --hard origin/main
sudo docker compose down
sudo docker compose up -d --build
sudo docker compose ps
remote: Enumerating objects: 20, done.
remote: Counting objects: 100% (20/20), done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 13 (delta 8), reused 13 (delta 8), pack-reused 0 (from 0)
Unpacking objects: 100% (13/13), 3.34 KiB | 284.00 KiB/s, done.
From github.com:ezesancruz/elpelasorteos-web
 * branch            main       -> FETCH_HEAD
   7d879bc..c521ed9  main       -> origin/main
HEAD is now at c521ed9 actualizacion probable. pp
[+] Running 3/3
 ✔ Container caddy      Removed                                            0.3s 
 ✔ Container web-web-1  Removed                                            0.8s 
 ✔ Network web_default  Removed                                            0.3s 
[+] Building 47.2s (17/17) FINISHED                                             
 => [internal] load local bake definitions                                 0.0s 
 => => reading from stdin 489B                                             0.0s
 => [internal] load build definition from Dockerfile                       0.0s
 => => transferring dockerfile: 1.10kB                                     0.0s 
 => resolve image config for docker-image://docker.io/docker/dockerfile:1  0.3s 
 => CACHED docker-image://docker.io/docker/dockerfile:1@sha256:b6afd42430  0.0s
 => [internal] load metadata for docker.io/library/node:20-alpine          0.1s
 => [internal] load .dockerignore                                          0.0s
 => => transferring context: 2B                                            0.0s 
 => [1/8] FROM docker.io/library/node:20-alpine@sha256:6178e78b972f79c335  0.0s
 => [internal] load build context                                          0.9s 
 => => transferring context: 571.03kB                                      0.8s 
 => CACHED [2/8] WORKDIR /app                                              0.0s
 => CACHED [3/8] RUN addgroup -S appgroup && adduser -S appuser -G appgro  0.0s 
 => CACHED [4/8] COPY package*.json ./                                     0.0s 
 => [5/8] RUN npm ci --only=production                                     7.0s 
 => [6/8] RUN apk add --no-cache python3  && ln -sf /usr/bin/python3 /usr  1.5s
 => [7/8] COPY . .                                                         5.7s
 => [8/8] RUN chown -R appuser:appgroup /app                              24.0s
 => exporting to image                                                     6.9s
 => => exporting layers                                                    6.8s
 => => writing image sha256:5c46069647e2936355f4d9d7bfda6ef69eae056c98b9a  0.0s
 => => naming to docker.io/library/web-web                                 0.0s
 => resolving provenance for metadata file                                 0.0s
[+] Running 4/4
 ✔ web-web              Built                                              0.0s 
 ✔ Network web_default  Created                                            0.1s 
 ✔ Container web-web-1  Started                                            0.6s 
 ✔ Container caddy      Started                                            0.8s 
NAME        IMAGE     COMMAND                  SERVICE   CREATED         STATUS                           PORTS
caddy       caddy:2   "caddy run --config …"   caddy     2 seconds ago   Up Less than a second            0.0.0.0:80->80/tcp, [::]:80->80/tcp, 0.0.0.0:443->443/tcp, [::]:443->443/tcp, 443/udp, 2019/tcp
web-web-1   web-web   "docker-entrypoint.s…"   web       2 seconds ago   Up 1 second (health: starting)   8080/tcp
bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose exec web sh -lc 'python /app/microservices/
        integracion_mercadopago_app/scripts/query_payment.py 130455149235 ||     
        true'
/usr/bin/python: can't find '__main__' module in '/app/microservices/'
sh: integracion_mercadopago_app/scripts/query_payment.py: not found
bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose exec web sh -lc 'wget -qO- "http://127.0.0.1:8080/api/   
        payments/verificar?op=130455149235"'
wget: server returned error: HTTP/1.1 400 Bad Request
bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose logs web | grep "/api/payments/verificar"
bitnami@ip-172-26-1-205:~/sorteo-web/web$ 






bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose exec web sh -lc 'ls -l /app/microservices/integracion_mercadopago_app/pagos.db'
-rw-r--r--    1 node     node        385024 Oct 27 04:41 /app/microservices/integracion_mercadopago_app/pagos.db
bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose exec web sh -lc 'python /app/microservices/integracion_mercadopago_app/scripts/query_payment.py 130455149235 || true'
{"ok": false, "error": "Error DB: attempt to write a readonly database"}

  1. Editar el script en el servidor para permitir fallback (RW) manteniendo    
     query_only                                                                 
                                                                                
  - Archivo a editar en el servidor:                                            
      - microservices/integracion_mercadopago_app/scripts/query_payment.py      
  - Reemplazá el bloque de conexión por este (es solo ese cambio):              
                                                                                
  try:                                                                          
  conn = sqlite3.connect(f"file:{DB_PATH}?mode=ro", uri=True,                   
  check_same_thread=False)                                                      
  conn.row_factory = sqlite3.Row                                                
  conn.execute("PRAGMA query_only = ON")                                        
  except Exception as e:                                                        
  conn = sqlite3.connect(str(DB_PATH), check_same_thread=False)                 
  conn.row_factory = sqlite3.Row                                                
  conn.execute("PRAGMA query_only = ON")   

  ↑↑↑
  eso ya lotengo exactamente asi en el servidor es mas te copio y pego abajo:
import json, sqlite3, sys
from pathlib import Path

# Localiza la base en el directorio del microservicio
BASE_DIR = Path(__file__).resolve().parents[1]
DB_PATH = BASE_DIR / 'pagos.db'

def main():
    if len(sys.argv) < 2:
        print(json.dumps({"ok": False, "error": "Falta parámetro op"}, ensure_a>        return 1

    op = sys.argv[1].strip()
    if not (op.isdigit() and 6 <= len(op) <= 24):
        print(json.dumps({"ok": False, "error": "Parámetro op inválido"}, ensur>        return 1

    if not DB_PATH.exists():
        print(json.dumps({"ok": False, "error": "Base de datos no encontrada"},>        return 1

    try:
        # Intento 1: abrir en modo solo lectura. En bases con WAL puede requerir        # crear archivos -shm; si el modo ro impide esa escritura, reintentamos>        try:
            conn = sqlite3.connect(f"file:{DB_PATH}?mode=ro", uri=True, check_s>            conn.row_factory = sqlite3.Row
            conn.execute("PRAGMA query_only = ON")
        except Exception as e:
            # Fallback: abrir sin mode=ro para permitir crear -wal/-shm si hace>            # Seguimos forzando PRAGMA query_only=ON para evitar escrituras de >            conn = sqlite3.connect(str(DB_PATH), check_same_thread=False)       
            conn.row_factory = sqlite3.Row
            conn.execute("PRAGMA query_only = ON")

        row = conn.execute(
            """
            SELECT numero_operacion, status, amount, currency, date_approved, p>
            FROM pagos WHERE numero_operacion = ?
              FROM pagos WHERE numero_operacion = ?
            """,
            (op,),
        ).fetchone()
    except Exception as e:
        print(json.dumps({"ok": False, "error": f"Error DB: {e}"}, ensure_ascii>        return 1
    finally:
        try:
            conn.close()
        except Exception:
            pass

    if not row:
        print(json.dumps({
            "verified": False,
            "numero_operacion": None,
            "status": None,
            "fecha": None,
            "monto": None,
            "moneda": "ARS",
            "payer_name": None,
            "description": None,
            "mensaje": "No encontrado. Si pagaste hace poco, puede demorar unos>        }, ensure_ascii=False))
        return 0

    aprobado = (row["status"] == "approved")
    resp = {
        "verified": bool(aprobado),
        "numero_operacion": row["numero_operacion"],
        "status": row["status"],
        "fecha": row["date_approved"],
        "monto": float(row["amount"]) if row["amount"] is not None else None,   
        "moneda": row["currency"] or "ARS",
        "payer_name": row["payer_name"],
        "description": row["description"],
        "mensaje": "El número de operación fue verificado con éxito." if aproba>    }
                                                                                    print(json.dumps(resp, ensure_ascii=False))
    return 0                                                                    

if __name__ == '__main__':
    raise SystemExit(main())


bitnami@ip-172-26-1-205:~/sorteo-web/web$ docker compose exec web sh -lc 'wget -qO- "http://127.0.0.1:8080/api/payments/verificar?op=130455149235"'
wget: server returned error: HTTP/1.1 500 Internal Server Error

y mi archivo local se ve asi
#!/usr/bin/env python3
import json, sqlite3, sys
from pathlib import Path

# Localiza la base en el directorio del microservicio
BASE_DIR = Path(__file__).resolve().parents[1]
DB_PATH = BASE_DIR / 'pagos.db'

def main():
    if len(sys.argv) < 2:
        print(json.dumps({"ok": False, "error": "Falta parámetro op"}, ensure_ascii=False))
        return 1

    op = sys.argv[1].strip()
    if not (op.isdigit() and 6 <= len(op) <= 24):
        print(json.dumps({"ok": False, "error": "Parámetro op inválido"}, ensure_ascii=False))
        return 1

    if not DB_PATH.exists():
        print(json.dumps({"ok": False, "error": "Base de datos no encontrada"}, ensure_ascii=False))
        return 1

    try:
        # Intento 1: abrir en modo solo lectura. En bases con WAL puede requerir
        # crear archivos -shm; si el modo ro impide esa escritura, reintentamos rw.
        try:
            conn = sqlite3.connect(f"file:{DB_PATH}?mode=ro", uri=True, check_same_thread=False)
            conn.row_factory = sqlite3.Row
            conn.execute("PRAGMA query_only = ON")
        except Exception as e:
            # Fallback: abrir sin mode=ro para permitir crear -wal/-shm si hace falta.
            # Seguimos forzando PRAGMA query_only=ON para evitar escrituras de datos.
            conn = sqlite3.connect(str(DB_PATH), check_same_thread=False)
            conn.row_factory = sqlite3.Row
            conn.execute("PRAGMA query_only = ON")

        row = conn.execute(
            """
            SELECT numero_operacion, status, amount, currency, date_approved, payer_name, description
            FROM pagos WHERE numero_operacion = ?
            """,
            (op,),
        ).fetchone()
    except Exception as e:
        print(json.dumps({"ok": False, "error": f"Error DB: {e}"}, ensure_ascii=False))
        return 1
    finally:
        try:
            conn.close()
        except Exception:
            pass

    if not row:
        print(json.dumps({
            "verified": False,
            "numero_operacion": None,
            "status": None,
            "fecha": None,
            "monto": None,
            "moneda": "ARS",
            "payer_name": None,
            "description": None,
            "mensaje": "No encontrado. Si pagaste hace poco, puede demorar unos minutos en sincronizarse."
        }, ensure_ascii=False))
        return 0

    aprobado = (row["status"] == "approved")
    resp = {
        "verified": bool(aprobado),
        "numero_operacion": row["numero_operacion"],
        "status": row["status"],
        "fecha": row["date_approved"],
        "monto": float(row["amount"]) if row["amount"] is not None else None,
        "moneda": row["currency"] or "ARS",
        "payer_name": row["payer_name"],
        "description": row["description"],
        "mensaje": "El número de operación fue verificado con éxito." if aprobado else "Pago aún no acreditado."
    }

    print(json.dumps(resp, ensure_ascii=False))
    return 0

if __name__ == '__main__':
    raise SystemExit(main())


SE VE TODO IGUAL, VISTE QUE PASA?