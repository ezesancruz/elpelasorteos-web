üõ†Ô∏è Plan por fases (instrucciones + resultado esperado)
Fase 1 ‚Äî Seguridad del editor (imprescindible)

Objetivo: en producci√≥n, ocultar el bot√≥n y bloquear las rutas de edici√≥n salvo con token.

1.1 Backend (Express)

A√±ad√≠ al inicio de server/editor-server.js (debajo de los require):

// === SECURITY FLAGS ===
const EDITOR_ENABLED = process.env.EDITOR_ENABLED === 'true';
const ADMIN_TOKEN = process.env.ADMIN_TOKEN || '';

app.get('/api/config', (_req, res) => {
  res.json({ editorEnabled: EDITOR_ENABLED });
});

function requireEditorEnabled(_req, res, next) {
  if (!EDITOR_ENABLED) return res.status(403).json({ error: 'editor disabled' });
  next();
}
function requireAdmin(req, res, next) {
  const token = req.get('x-admin-token') || req.query.token || '';
  if (!token || token !== ADMIN_TOKEN) return res.status(401).json({ error: 'unauthorized' });
  next();
}


Luego, envolv√© solo endpoints de escritura:

app.put('/api/content', requireEditorEnabled, requireAdmin, /* handler actual */);
app.post('/api/upload', requireEditorEnabled, requireAdmin, upload.single('image'), /* handler actual */);


(Dej√° GET /api/content libre para el front.)

1.2 Frontend (editor)

En scripts/editor.js, reemplaz√° el listener inicial por esto (para no renderizar el editor si est√° deshabilitado):

document.addEventListener('DOMContentLoaded', async () => {
  try {
    const cfg = await fetch('/api/config').then(r => r.json());
    if (!cfg?.editorEnabled) return; // no mostramos el editor en prod
  } catch (_) {}
  waitForApp().then(initEditor).catch(err => console.error(err));
});


Variables en producci√≥n: EDITOR_ENABLED=false y ADMIN_TOKEN (largo).
Resultado esperado: el bot√≥n del editor no aparece en prod; los POST/PUT devuelven 403/401 si no mand√°s x-admin-token.

Fase 2 ‚Äî Personalizaci√≥n SEO & Open Graph

Objetivo: metas correctas para marca, redes y previsualizaci√≥n.

En index.html (en <head>):

<title>elpelasorteos.shop ‚Äî Sorteos en vivo y transparentes</title>
<meta name="description" content="Particip√° f√°cil, en vivo y con ganadores verificados. Sumate al pr√≥ximo sorteo.">
<link rel="canonical" href="https://elpelasorteos.shop/">

<meta property="og:title" content="elpelasorteos.shop ‚Äî Sorteos en vivo y transparentes">
<meta property="og:description" content="Particip√° f√°cil, en vivo y con ganadores verificados.">
<meta property="og:image" content="https://elpelasorteos.shop/og-image.jpg">
<meta property="og:url" content="https://elpelasorteos.shop/">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">

<link rel="icon" href="/favicon.ico">


Cre√° estos archivos en la ra√≠z del sitio (carpeta web/):

robots.txt

User-agent: *
Allow: /
Sitemap: https://elpelasorteos.shop/sitemap.xml


sitemap.xml

<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url><loc>https://elpelasorteos.shop/</loc></url>
  <url><loc>https://elpelasorteos.shop/ganadoresanteriores/</loc></url>
</urlset>


Resultado esperado: snippets correctos en WhatsApp/FB/Twitter, canonical √∫nico, y bots con acceso completo.

Fase 3 ‚Äî Analytics (GA4 real + eventos clave)

Objetivo: medir CTA, packs y redes sin tocar mucho el markup.

Reemplaz√° G-XXXXXXXXXX por tu Measurement ID en index.html.

Al final de scripts/app.js, agreg√° delegaci√≥n de eventos:

// Eventos m√≠nimos sin cambiar HTML
document.addEventListener('click', (e) => {
  const a = e.target.closest('a');
  if (!a) return;

  // Click en redes (lista de √≠conos)
  if (a.closest('.social-list')) {
    track('social_click', { platform: a.getAttribute('aria-label') || a.href });
  }

  // Click en packs de compra (links a mpago.la)
  if (/mpago\.la|mercadopago/i.test(a.href)) {
    const label = (a.textContent || '').trim();
    track('pack_click', { label });
  }

  // CTA principal (heur√≠stica por texto)
  if (/mpago\.la|mercadopago/i.test(a.href) && /participar|comprar/i.test(a.textContent)) {
    track('cta_participar_click', { location: 'hero' });
  }
});


Resultado esperado: ves social_click, pack_click, cta_participar_click llegar a GA4 ‚Üí luego los marc√°s como conversiones.

Fase 4 ‚Äî Docker + Caddy (HTTPS, reverse proxy y persistencia)

Objetivo: despliegue reproducible en Lightsail con volumen persistente para /uploads.

Coloc√° estos tres archivos en la ra√≠z del repo (al lado de la carpeta web/):

Dockerfile

# syntax=docker/dockerfile:1
FROM node:20-alpine
WORKDIR /app
# Sharp en Alpine
RUN apk add --no-cache libc6-compat
# Instalar deps en /app/web
COPY web/package*.json ./web/
RUN cd web && npm ci --only=production
# Copiar el proyecto
COPY web ./web
ENV NODE_ENV=production
ENV PORT=8080
WORKDIR /app/web
EXPOSE 8080
CMD ["npm", "start"]


docker-compose.yml

services:
  web:
    build: .
    container_name: web
    env_file: .env
    environment:
      - PORT=8080
    volumes:
      - uploads:/app/web/server/public/uploads
    restart: always

  caddy:
    image: caddy:2
    container_name: caddy
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile
      - caddy_data:/data
      - caddy_config:/config
    depends_on:
      - web
    restart: always

volumes:
  uploads:
  caddy_data:
  caddy_config:


Caddyfile

elpelasorteos.shop, www.elpelasorteos.shop {
  encode zstd gzip
  tls tu@correo.com
  reverse_proxy web:8080
}


.env (crear en la ra√≠z, no subir a Git)

EDITOR_ENABLED=false
ADMIN_TOKEN=pon√©-un-token-largo-y-unico
PORT=8080


Resultado esperado: Caddy emite SSL autom√°tico y proxy a Express. Las im√°genes subidas sobreviven reinicios por el volumen uploads:.

Fase 5 ‚Äî AWS Lightsail (deploy real)

En tu instancia (Ubuntu):

# 1) Docker y compose plugin
sudo apt-get update -y
sudo apt-get install -y docker.io docker-compose-plugin
sudo systemctl enable --now docker

# 2) Traer el repo
git clone https://github.com/tu-usuario/tu-repo.git
cd tu-repo

# 3) Variables de entorno
cp .env.example .env   # si no ten√©s, cre√° .env con el contenido de arriba
nano .env              # completa ADMIN_TOKEN

# 4) Build & up
sudo docker compose up -d --build

# 5) Logs (opcional)
sudo docker compose logs -f


Abr√≠ puertos en Lightsail (80/443) y asign√° Static IP.

Resultado esperado: https://elpelasorteos.shop responde con tu sitio (HTTP ‚Üí HTTPS).
curl -I https://elpelasorteos.shop devuelve HTTP/2 200.

Fase 6 ‚Äî DNS (Namecheap ‚Üí Lightsail)

A (@) ‚Üí IP est√°tica de tu instancia Lightsail

CNAME (www) ‚Üí elpelasorteos.shop

Resultado esperado: www y ra√≠z apuntan al mismo sitio; Caddy genera certificados para ambos.

Fase 7 ‚Äî Pre-render (opcional, mejora SEO t√©cnico)

Si quer√©s publicar snapshots:

# Local o en CI
cd web
npm run prerender   # genera /dist


Opciones:

Modo actual (din√°mico): segu√≠s sirviendo Express (ya indexable).

Modo est√°tico para bots: servir /dist a user-agents de buscadores (requiere peque√±a l√≥gica adicional).

Hosting est√°tico: publicar solo dist/ (si prescind√≠s del editor en prod).

Resultado esperado: contenido HTML ‚Äúplano‚Äù por ruta (/ y /ganadoresanteriores/), mejorando la vista previa de bots.

Fase 8 ‚Äî Pruebas de humo (checklist final)

üîí Editor oculto en prod: bot√≥n ausente y PUT/POST devuelven 403/401 sin token.

üñºÔ∏è Subidas persisten tras docker compose restart.

üåê HTTPS v√°lido en ra√≠z y www.

üß≠ SEO: <title>, description, canonical, OG/Twitter OK; robots.txt y sitemap.xml accesibles.

üìä GA4 recibiendo social_click, pack_click, cta_participar_click.

üï∏Ô∏è Links de pago (mpago.la) funcionales.

üß± Backups: git actualizado; volumen uploads persistente (snapshot en Lightsail opcional).

Qu√© vas a ver al terminar

Sitio en producci√≥n en https://elpelasorteos.shop con SSL y performance estable.

Editor blindado (solo habilitable con env y token).

M√©tricas GA4 listas para tomar decisiones (qu√© pack/CTA funciona mejor).

SEO prolijo (metas + sitemap + canonical) y opcionalmente pre-render.