Resumido en una línea: en local la tarjeta “Validación de participación” consulta bien a tu API/DB, pero en producción (elpelasorteos.shop) la llamada falla y tu UI muestra el mensaje genérico “No se pudo comprobar ahora…”.

Qué suele causar exactamente esa diferencia local vs prod

Te dejo las 5 causas más probables (en orden de probabilidad por lo que contás y lo que ya vimos de tu stack):

La URL de la API quedó “localhost” en el bundle de producción.
Con Vite/React/lo-que-uses, las variables tipo VITE_API_URL se “hornean” en el build.

En tu compu funciona porque el browser llama a http://localhost:XXXX.

En producción, el browser del usuario intenta llamar a su propio http://localhost:XXXX → falla → tu catch muestra “No se pudo comprobar ahora”.

Síntoma clarísimo: en las DevTools de la página en producción, el request de la tarjeta apunta a http://localhost:... o a un puerto dev (5173/8080/etc.).

Contenido mixto (HTTPS sitio / HTTP API).
Si tu web va por https y la API está en http, el navegador bloquea la solicitud. También dispara tu mensaje genérico.

Proxy inverso mal mapeado (Nginx/Caddy) para /api.
En local tal vez tenés proxy del dev server; en prod, /api/... podría estar yendo al frontend (404) en vez del backend. Tu código ve !ok o error de red y muestra “No se pudo…”.

CORS/Preflight.
Si estás llamando a otro dominio (p. ej. api.tudominio) y el backend no devuelve los headers CORS correctos, el browser lo bloquea.

Conexión del backend a la DB en Docker.
Dentro del contenedor, localhost no es la máquina host. Si el API usa DB_HOST=localhost pero la DB está en otro contenedor o en el host, en prod el backend puede estar tirando 500. (Local no, porque todo corre en tu máquina.)

“Chequeo express” (2 minutos) para confirmar la causa

Hacelo desde tu navegador en producción (elpelasorteos.shop):

Abrí DevTools → pestaña Network.
Ingresá un número y apretá Comprobar.

Fijate la Request URL:

¿Apunta a http://localhost:XXXX? → Causa #1 confirmada.

¿Apunta a http://... y tu sitio es https://...? → Causa #2.

¿Apunta a /api/... y devuelve 404 o 502 del frontend/proxy? → Causa #3.

¿Ves error de CORS en consola? → Causa #4.

¿Status 500 del backend? Mirá los logs → puede ser causa #5.

Extra: view-source del bundle: buscá localhost: o el puerto 5173/8080. Si aparece, está horneado en el build.

Cómo lo dejamos sólido (fix por escenario)

Escenario A — URL “localhost” horneada en el build (el más común):

En el frontend usá ruta relativa siempre: fetch('/api/validar?numero=...')
(Así hereda el mismo origen/https y te olvidás de CORS y mixed content.)

Si necesitás absoluto, usá VITE_API_URL=https://elpelasorteos.shop en un .env.production y asegurate que el build de Docker/CI lo lea (p. ej. --env-file .env.production o ARG/ENV en Dockerfile).

Re-build y redeploy.

Escenario B — Mixed content (https vs http):

Poner https al backend (o servirlo por el mismo dominio con proxy /api).

O usa siempre ruta relativa '/api/...' detrás del proxy.

Escenario C — Proxy inverso:

En Nginx/Caddy asegurate de mapear /api al backend. Ejemplo Caddy:

elpelasorteos.shop {
  reverse_proxy /api/* api:5001
  reverse_proxy /* web:3000
}


(Ajustá puertos/nombres de servicio según tu docker-compose.)

Escenario D — CORS:

Si sí o sí vas cross-domain, agregá en el backend:

Access-Control-Allow-Origin: https://elpelasorteos.shop
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization


y manejá OPTIONS.

Escenario E — DB desde Docker:

En docker-compose.yml, usá nombre de servicio (DB_HOST=db) o si es DB en host, host.docker.internal (o agregalo vía extra_hosts) y exponé el puerto.

Sobre editar archivos en el servidor

.env del servidor: está bien que sea distinto y no esté en Git.

Ojo: si tu .env sí está trackeado en Git, el git reset --hard origin/main lo va a pisar. Metelo en .gitignore y usá env_file: o environment: en Compose.

Si actualizás .env que afecta el build del frontend (ej. VITE_...), tenés que reconstruir la imagen (docker compose up -d --build web), porque esas variables se hornean en el bundle.